/**
 * Created by Rob on 7/7/2017.
 * SyntaxAnalyzer provides parsing of the sequence of tokens to make sure sentences in the language are correct
 */

package Parser;

import Lexer.LexicalAnalyzer;
import Lexer.Token;
import Lexer.TokenType;

import java.util.HashMap;


public class SyntaxAnalyzer {

    private LexicalAnalyzer lexer;
    private Token nextToken;
    private HashMap<String, String> identifiersTable = new HashMap<>();



    public SyntaxAnalyzer(LexicalAnalyzer lexer) {
        this.lexer = lexer;
        this.nextToken = lexer.getNextToken();
    }


    // parse() traverses through the list of tokens and does syntax analysis based on the rules of the language
    public void parse() {
        start();
    }


    /* start()
    Parses strings in the language generated by the rule:
    start : symbols forward_refs globals implement
     */
    private void start() {

        while (nextToken.getTokType() != TokenType.EOS_TOK) {

            if (nextToken.getTokType() == TokenType.SYMBOL_TOK) {
                // parse symbols
                symbols();
            }
            else if (nextToken.getTokType() == TokenType.FORWARD_TOK) {

                // parse forward_refs
                forward_refs();
            }
            else if (nextToken.getTokType() == TokenType.GLOBAL_TOK) {

                // parse globals()
                globals();
            }
            else if (nextToken.getTokType() == TokenType.IMPLEMENTATIONS_TOK) {

                // parse implement()
                implement();
            }
        }

    }



    /* symbols()
    parses strings in the language generated by the rule:
    symbols :
            | symbols symbol_def
     */
    private void symbols() {
        System.out.println("Enter <symbols>");

            // check for symbol token
            while (nextToken.getTokType() == TokenType.SYMBOL_TOK) {

                // show token
                printToken();

                // consume the token
                nextToken = lexer.getNextToken();

                // parse symbols_def
                symbols_def();
            }

        System.out.println("Exit <symbols>");
    }



    /* symbols_def()
    parses strings in the language generated by the rule:
    symbol_def : SYMBOL IDENTIFIER
     */
    private void symbols_def() {
        System.out.println("Enter <symbols_def>");

        // check to see if we have identifier token
        if (nextToken.getTokType() != TokenType.ID_TOK) {

            // token is not an identifier, so error
            error("identifier");

        } else {

            // show token
            printToken();

            // consume the token
            nextToken = lexer.getNextToken();


        }

        System.out.println("Exit <symbols_def>");
    }



    /* forward_refs()
    parses strings in the language generated by the rule:
    forward_refs : FORWARD frefs
     */
    private void forward_refs() {
        System.out.println("Enter <forward_refs>");

            // check for FORWARD keyword
            if (nextToken.getTokType() == TokenType.FORWARD_TOK) {

                // show token
                printToken();

                // consume the token
                nextToken = lexer.getNextToken();

                // parse frefs
                frefs();
            }

        System.out.println("Exit <forward_refs>");
    }



    /* frefs()
    parses strings in the language generated by the rule:
    frefs : REFERENCES forward_list  |  DECLARATIONS forward_list  |  forward_list
     */
    private void frefs() {
        System.out.println("Enter <frefs>");

        // check for REFERENCES keyword and DECLARATIONS keyword
        if (nextToken.getTokType() == TokenType.REFERENCES_TOK) {

            // show token
            printToken();

            // consume the token
            nextToken = lexer.getNextToken();


        }
        // check for DECLARATIONS keyword
        else if (nextToken.getTokType() == TokenType.DECLARATIONS_TOK) {

            // show token
            printToken();

            // consume the token
            nextToken = lexer.getNextToken();
        }

        // parse forward_list()
        forward_list();


        System.out.println("Exit <frefs>");
    }



    /* forward_list()
    parses strings in the language generated by the rule:
    forward_list : forwards | forward_list forwards
     */
    private void forward_list() {
        System.out.println("Enter <forward_list>");

        // parse forwards
        forwards();

        System.out.println("Exit <forward_list>");
    }



    /* forwards()
    parses strings in the language generated by the rule:
    forwards :
         | func_main dec_parameters
         ;
     */
    private void forwards() {
        System.out.println("Enter <forwards>");

        // parse func_main
        func_main();

        System.out.println("Exit <forwards>");
    }



    /* func_main()
    parses strings in the language generated by the rule:
    func_main :
          | FUNCTION IDENTIFIER oper_type
          | MAIN {dec_main();}
          ;
     */
    private void func_main() {
        System.out.println("Enter <func_main>");

        if (nextToken.getTokType() == TokenType.FUNCTION_TOK) {

            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();

            if (nextToken.getTokType() == TokenType.ID_TOK) {

                // show the token
                printToken();

                // consume token
                nextToken = lexer.getNextToken();

                // parse oper_type
                oper_type();

            } else if (nextToken.getTokType() == TokenType.MAIN_TOK) {

                // show the token
                printToken();

                // consume token
                nextToken = lexer.getNextToken();
            } else {
                error("identifer or Main");
            }

        }

        System.out.println("Exit <func_main>");
    }



    /* oper_type()
    parses strings in the language generated by the rule:
    oper_type : RETURN  chk_array ret_type
          ;
     */
    private void oper_type() {
        System.out.println("Enter <oper_type>");

        // check for RETURN keyword, if not error
        if (nextToken.getTokType() != TokenType.RETURN_TOK) {

            error("Return");

        } else {

            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();

            // parse chk_array
            chk_array();

            // parse ret_type
            ret_type();

        }

        System.out.println("Exit <oper_type>");
    }



    /* chk_array()
    parses strings in the language generated by the rule:
    chk_array :
          | ARRAY array_dim_list
          ;
     */
    private void chk_array() {
        System.out.println("Enter <chk_array>");

        // check for ARRAY keyword
        if (nextToken.getTokType() == TokenType.ARRAY_TOK) {

            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();

            // parse array_dim_list
            array_dim_list();
        }



        System.out.println("Exit <chk_array>");
    }



    /* ret_type()
    parses strings in the language generated by the rule:
    ret_type  : TYPE type_name
          | STRUCT IDENTIFIER
          | STRUCTYPE IDENTIFIER
          ;
     */
    private void ret_type() {
        System.out.println("Enter <ret_type>");

        // check for TYPE keyword
        if (nextToken.getTokType() == TokenType.TYPE_TOK) {

            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();

            // parse type_name
            type_name();

        }
        // check for STRUCT keyword
        else if (nextToken.getTokType() == TokenType.STRUCT_TOK) {

            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();


            // check for identifier
            if (nextToken.getTokType() != TokenType.ID_TOK) {

                // display error
                error("identifier");

            }
            else {

                // show the token
                printToken();

                // consume token
                nextToken = lexer.getNextToken();
            }
        }
        // didnt get correct keywords, so error
        else {

            error("Type or Struct");

        }

        System.out.println("Exit <ret_type>");
    }



    /* array_dim_list()
    parses strings in the language generated by the rule:
    array_dim_list : LB array_index RB
                   | array_dim_list LB array_index RB
                   ;
     */
    private void array_dim_list() {
        System.out.println("Enter <array_dim_list>");

        if (nextToken.getTokType() == TokenType.LEFTBRACKET_TOK) {

            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();

            // parse array_index
            array_index();

            if (nextToken.getTokType() == TokenType.RIGHTBRACKET_TOK) {
                // show the token
                printToken();

                // consume token
                nextToken = lexer.getNextToken();
            } else {

                // expected right bracket but got something else, error
                error("]");

            }
        }

        System.out.println("Exit <array_dim_list>");
    }



    /* array_dim_list()
    parses strings in the language generated by the rule:
    array_dim_list : LB array_index RB
                   | array_dim_list LB array_index RB
                   ;
 */
    private void array_index() {
        System.out.println("Enter <array_index>");

        // check for identifier, if not error
        if (nextToken.getTokType() != TokenType.ID_TOK) {

            error("Identifier");

        } else {

            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();
        }

        System.out.println("Exit <array_index>");
    }




    /* type_name()
    parses strings in the language generated by the rule:
    type_name       : MVOID
                    | INTEGER
                    | SHORT
                    ;
    */
    private void type_name() {
        System.out.println("Enter <type_name>");

        // check for integer, if no integer display error
        if (nextToken.getTokType() != TokenType.INTEGER_TOK) {

            error("Integer");

        }

        else {

            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();
        }


        System.out.println("Exit <type_name>");
    }




    // ------------------------------------------------ globals



    /* globals()
    parses strings in the language generated by the rule:
    globals :
        | GLOBAL declarations
        ;
    */
    private void globals() {
        System.out.println("Enter <globals>");

        if (nextToken.getTokType() == TokenType.GLOBAL_TOK) {

            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();

            // parse declarations
            declarations();
        }

        System.out.println("Exit <globals>");
    }




    /* declarations()
    parses strings in the language generated by the rule:
    declarations :
             | DECLARATIONS const_dec var_dec
             ;
    */
    private void declarations() {
        System.out.println("Enter <declarations>");

        if (nextToken.getTokType() == TokenType.DECLARATIONS_TOK) {

            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();

            // parse const_dec
            const_dec();

            // parse var_dec
            var_dec();
        }

        System.out.println("Exit <declarations>");
    }



    /* const_dec()
    parses strings in the language generated by the rule:
    const_dec : CONSTANTS const_list
          ;
    */
    private void const_dec() {
        System.out.println("Enter <const_dec>");

        if (nextToken.getTokType() != TokenType.CONSTANT_TOK) {

            error("CONSTANT");

        } else {


            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();

            // parse const_list
            const_list();
        }

        System.out.println("Exit <const_dec>");
    }



    /* const_list()
    parses strings in the language generated by the rule:
    const_list : const_list DEFINE identifier rec_type equal_op constant_val
           ;
*/
    private void const_list() {
        System.out.println("Enter <const_list>");

        while (nextToken.getTokType() == TokenType.CONSTANT_TOK) {
            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();

            // parse const_list
            const_list();
        }

        // check for DEFINE keyword
        if (nextToken.getTokType() != TokenType.DEFINE_TOK) {

            error("DEFINE");

        } else {

            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();

            // check for Identifier
            if (nextToken.getTokType() != TokenType.ID_TOK) {

                error("Identifier");

            } else {
                // show the token
                printToken();

                // consume token
                nextToken = lexer.getNextToken();

                // parse rec_type
                // TODO  (Asked Garrido about rec_type ????
                // rec_type();
            }
        }

        System.out.println("Exit <const_list>");
    }


    /* var_dec()
    parses strings in the language generated by the rule:
    var_dec : VARIABLES var_list
        ;
    */
    private void var_dec() {
        System.out.println("Enter <var_dec>");

        // parse rec_type
        // TODO  (Asked Garrido about rec_type ????
        // rec_type();


        System.out.println("Exit <var_dec>");
    }




    // ------------------------------------------------ implementation


    /* implement()
    parses strings in the language generated by the rule:
    implement : IMPLEMENTATIONS funct_list
          ;
    */
    private void implement() {
        System.out.println("Enter <implement>");

        if (nextToken.getTokType() != TokenType.IMPLEMENTATIONS_TOK) {

            error("IMPLEMENT");

        } else {
            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();

            // parse func_list
            funct_list();
        }

        System.out.println("Exit <implement>");
    }


    /* funct_list()
    parses strings in the language generated by the rule:
    funct_list : funct_def
           | funct_list funct_def
           ;
    */
    private void funct_list() {
        System.out.println("Enter <funct_list>");

        //TODO fix while loop
        // parse funct_def
        funct_def();

        System.out.println("Exit <funct_list>");
    }



    /* funct_def()
    parses strings in the language generated by the rule:
    funct_list : funct_def
           | funct_list funct_def
           ;
    */
    private void funct_def() {
        System.out.println("Enter <funct_def>");

        // parse funct_body
        funct_body();

        System.out.println("Exit <funct_def>");
    }



    /* funct_body()
   parses strings in the language generated by the rule:
   funct_list : funct_def
          | funct_list funct_def
          ;
   */
    private void funct_body() {
        System.out.println("Enter <funct_body>");

        if (nextToken.getTokType() != TokenType.FUNCTION_TOK) {
            error("FUNCTION");
        } else {
            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();

            // parse main_head
            main_head();

            // parse parameters
            parameters();

            // parse f_body
            f_body();
        }


        System.out.println("Exit <funct_body>");
    }




    /* main_head()
    parses strings in the language generated by the rule:
    main_head : MAIN
          | IDENTIFIER
          ;
    */
    private void main_head() {
        System.out.println("Enter <main_head>");

        if (nextToken.getTokType() == TokenType.MAIN_TOK) {
            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();

        }

        else if (nextToken.getTokType() == TokenType.ID_TOK) {
            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();

        }

        else {
            error("MAIN or ID");
        }

        System.out.println("Exit <main_head>");
    }




    /* parameters()
    parses strings in the language generated by the rule:
    parameters :
           | PARAMETERS param_list
           ;
    */
    private void parameters() {
        System.out.println("Enter <parameters>");

        if (nextToken.getTokType() != TokenType.PARAMETERS_TOK) {
            error("PARAMETERS");
        }

        else {
            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();

            // parse param_list
            param_list();

        }


        System.out.println("Exit <parameters>");
    }




    /* param_list()
    parses strings in the language generated by the rule:
    param_list : param_def
           | param_list COMMA param_def
           ;
    */
    private void param_list() {
        System.out.println("Enter <param_list>");

        // parse param_def
        //TODO fix while loop
        param_def();

        System.out.println("Exit <param_list>");
    }



    /* param_def()
    parses strings in the language generated by the rule:
    param_def : identifier chk_const chk_ptr chk_array TYPE type_name
          ;
    */
    private void param_def() {
        System.out.println("Enter <param_list>");

        if (nextToken.getTokType() != TokenType.ID_TOK) {

            error("Identifier");

        } else {

            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();

            // parse chk_const
            chk_const();

            // parse chk_ptr
            // TODO
            //chk_ptr();

            // parse chk_array
            chk_array();

            if (nextToken.getTokType() != TokenType.TYPE_TOK) {
                error("TYPE");
            } else {

                // show the token
                printToken();

                // consume token
                nextToken = lexer.getNextToken();

                // parse type_name
                type_name();
            }
        }

        System.out.println("Exit <param_list>");
    }



    /* chk_const()
    parses strings in the language generated by the rule:
    chk_const :
          | CONSTANT
          ;
    */
    private void chk_const() {
        System.out.println("Enter <chk_const>");

        if (nextToken.getTokType() != TokenType.CONSTANT_TOK) {
            error("CONSTANT");
        }
        else {
            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();
        }


        System.out.println("Exit <chk_const>");
    }



    /* f_body()
    parses strings in the language generated by the rule:
    f_body : declarations BEGIN <statement_list> ENDFUN
       ;
    */
    private void f_body() {
        System.out.println("Enter <f_body>");

        // parse declarations
        declarations();

        if (nextToken.getTokType() != TokenType.BEGIN_TOK) {
            error("BEGIN");
        } else {

            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();

            // parse statement_list
            statement_list();

            if (nextToken.getTokType() != TokenType.ENDFUN_TOK) {
                error("BEGIN");
            } else {
                // show the token
                printToken();

                // consume token
                nextToken = lexer.getNextToken();
            }
        }
        System.out.println("Exit <f_body>");
    }



    /* statement_list()
    parses strings in the language generated by the rule:
    statement_list : statement
               | statement_list statement
               ;
    */
    private void statement_list() {
        System.out.println("Enter <statement_list>");

        //TODO fix while loop
        //parse statement
        statement();


        System.out.println("Exit <statement_list>");
    }



    /* statement_list()
    parses strings in the language generated by the rule:
    statement : if_statement
          | assignment_statement
		  | while_statement
		  | print_statement
		  | repeat_statement
          ;
    */
    private void statement() {
        System.out.println("Enter <statement>");

        if (nextToken.getTokType() == TokenType.IF_TOK) {
            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();

            // parse if_statement
            if_statement();
        }

        else if (nextToken.getTokType() == TokenType.SET_TOK) {
            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();

            // parse if_statement
            assignment_statement();
        }

        else if (nextToken.getTokType() == TokenType.WHILE_TOK) {
            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();

            // parse while_statement
            while_statement();
        }

        else if (nextToken.getTokType() == TokenType.REPEAT_TOK) {
            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();

            // parse repeat_statement
            repeat_statement();

        } else {
            error("IF ASSIGN or REPEAT");
        }


        System.out.println("Exit <statement>");
    }




    /* if_statement()
    parses strings in the language generated by the rule:
    if_statement : IF boolean_expression THEN statement_list
      ELSE statement_list ENDIF
    */
    private void if_statement() {
        System.out.println("Enter <if_statement>");

            // parse boolean_expression
            boolean_expression();

            if (nextToken.getTokType() != TokenType.THEN_TOK) {
                error("THEN");
            } else {

                // show the token
                printToken();

                // consume token
                nextToken = lexer.getNextToken();

                // parse statement_list
                statement_list();

                if (nextToken.getTokType() != TokenType.ELSE_TOK) {
                    error("ELSE");
                } else {

                    // show the token
                    printToken();

                    // consume token
                    nextToken = lexer.getNextToken();

                    // parse statement_list
                    statement_list();


                    if (nextToken.getTokType() != TokenType.ENDIF_TOK) {
                        error("ENDIF");
                    } else {

                        // show the token
                        printToken();

                        // consume token
                        nextToken = lexer.getNextToken();

                    }
                }
            }


        System.out.println("Exit <if_statement>");
    }



    /* while_statement()
    parses strings in the language generated by the rule:
    while_statement : WHILE boolean_expression DO statement_list ENDWHILE
                ;
    */
    private void while_statement() {
        System.out.println("Enter <while_statement>");

            // parse boolean_expression
            boolean_expression();

            if (nextToken.getTokType() != TokenType.DO_TOK) {
                error("DO");
            } else {

                // show the token
                printToken();

                // consume token
                nextToken = lexer.getNextToken();

                // parse statement_list
                statement_list();

                if (nextToken.getTokType() != TokenType.ENDWHILE_TOK) {
                    error("ENDWHILE");
                } else {

                    // show the token
                    printToken();

                    // consume token
                    nextToken = lexer.getNextToken();

                }
            }

        System.out.println("Exit <while_statement>");
    }



    /* assignment_statement()
    parses strings in the language generated by the rule:
    assignment_statement : SET identifier assignment_operator arithmetic_expression
                     ;
    */
    private void assignment_statement() {
        System.out.println("Enter <assign_statement>");


        if (nextToken.getTokType() != TokenType.ID_TOK) {
            error("Identifier");
        } else {

            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();

            if (nextToken.getTokType() != TokenType.ASSIGN_TOK) {
                error("=");
            } else {

                // show token
                printToken();

                // consume token
                nextToken = lexer.getNextToken();


                // parse arithmetic_expression
                arithmetic_exp();
            }


        }

        System.out.println("Exit <assignment_statement>");
    }





    /* repeat_statement()
    parses strings in the language generated by the rule:
    repeat_statement : REPEAT statement_list UNTIL boolean_expression ENDREPEAT
                 ;
    */
    private void repeat_statement() {
        System.out.println("Enter <repeat_statement>");

        //TODO

        System.out.println("Exit <repeat_statement>");
    }




    /* boolean_expression()
    parses strings in the language generated by the rule:
    boolean_expression : arithmetic_exp relative_op arithmetic_exp
    */
    private void boolean_expression() {
        System.out.println("Enter <boolean_expression>");

        // parse arithmetic_exp
        arithmetic_exp();

        // parse relative_op
        relative_op();

        // parse arithmetic_exp
        arithmetic_exp();

        System.out.println("Exit <boolean_expression>");
    }



    /* arg_list()
    parses strings in the language generated by the rule:
    arg_list : args
         | arg_list comma args
		 ;
    */
    private void arg_list() {
        System.out.println("Enter <arg_list>");

        //TODO recursion
        // parse args
        args();

        System.out.println("Exit <arg_list>");
    }




    /* args()
    parses strings in the language generated by the rule:
    args : identifier
     | constant
     | string
	 ;
    */
    private void args() {
        System.out.println("Enter <args>");

        if (nextToken.getTokType() != TokenType.ID_TOK || nextToken.getTokType() != TokenType.CONSTANT_TOK) {
            error("identifier or constant");
        } else {

            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();
        }


        System.out.println("Exit <args>");
    }



    /* relative_op()
    parses strings in the language generated by the rule:
    relative_op : le_operator | lt_operator | ge_operator | gt_operator | eq_operator | ne_operator
                ;
    */
    private void relative_op() {
        System.out.println("Enter <relative_op>");

        if (nextToken.getTokType() == TokenType.LE_TOK) {

            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();
        }

        else if (nextToken.getTokType() == TokenType.LT_TOK) {

            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();
        }

        else if (nextToken.getTokType() == TokenType.GE_TOK) {

            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();
        }
        else if (nextToken.getTokType() == TokenType.GT_TOK) {

            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();
        }
        else if (nextToken.getTokType() == TokenType.EQ_TOK) {

            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();
        }
        else if (nextToken.getTokType() == TokenType.NE_TOK) {

            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();
        }
        else {

            //error
            error("relative operator");
        }

            System.out.println("Exit <relative_op>");
    }




    /* arithmetic_exp()
    parses strings in the language generated by the rule:
    arithmetic_exp : arithmetic_exp add_operator mulexp
               | arithmetic_exp sub_operator mulexp
			   | mulexp
			   ;
    */
    private void arithmetic_exp() {
        System.out.println("Enter <arithmetic_expression>");

        if (nextToken.getTokType() == TokenType.ADD_TOK) {
            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();

        }

        else if (nextToken.getTokType() == TokenType.SUB_TOK) {
            // show the token
            printToken();

            // consume token
            nextToken = lexer.getNextToken();

        }

        else if (nextToken.getTokType() == TokenType.MUL_TOK) {
        // show the token
        printToken();

        // consume token
        nextToken = lexer.getNextToken();

        }

        else if (nextToken.getTokType() == TokenType.DIV_TOK) {
        // show the token
        printToken();

        // consume token
        nextToken = lexer.getNextToken();

        }



        System.out.println("Exit <arithmetic_expression>");
    }












    private void printToken() {
        System.out.println();
        System.out.printf("   Next token is: %s (%s) lexeme is: %s \n", nextToken.getTokType(), nextToken.getTokCode(), nextToken.getLexeme());
        System.out.println();
    }

    private void error(String s) {
        System.out.println("Invalid Syntax Error at line: " + nextToken.getRowNumber() + " col: " + nextToken.getColNumber() + " Expected \"" + s + "\" and received: \"" + nextToken.getLexeme() + "\" of Type: " + nextToken.getTokType());

    }

}
